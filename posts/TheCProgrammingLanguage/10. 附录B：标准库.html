<!DOCTYPE html><html><head>
      <title>10. &#x9644;&#x5F55;B&#xFF1A;&#x6807;&#x51C6;&#x5E93;</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.css">
      
      
      
      
      
      
      
      
      
      <style>
      /**
 * prism.js Github theme based on GitHub's theme.
 * @author Sam Clarke
 */
code[class*="language-"],
pre[class*="language-"] {
  color: #333;
  background: none;
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.4;

  -moz-tab-size: 8;
  -o-tab-size: 8;
  tab-size: 8;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
  padding: .8em;
  overflow: auto;
  /* border: 1px solid #ddd; */
  border-radius: 3px;
  /* background: #fff; */
  background: #f5f5f5;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
  white-space: normal;
  background: #f5f5f5;
}

.token.comment,
.token.blockquote {
  color: #969896;
}

.token.cdata {
  color: #183691;
}

.token.doctype,
.token.punctuation,
.token.variable,
.token.macro.property {
  color: #333;
}

.token.operator,
.token.important,
.token.keyword,
.token.rule,
.token.builtin {
  color: #a71d5d;
}

.token.string,
.token.url,
.token.regex,
.token.attr-value {
  color: #183691;
}

.token.property,
.token.number,
.token.boolean,
.token.entity,
.token.atrule,
.token.constant,
.token.symbol,
.token.command,
.token.code {
  color: #0086b3;
}

.token.tag,
.token.selector,
.token.prolog {
  color: #63a35c;
}

.token.function,
.token.namespace,
.token.pseudo-element,
.token.class,
.token.class-name,
.token.pseudo-class,
.token.id,
.token.url-reference .token.variable,
.token.attr-name {
  color: #795da3;
}

.token.entity {
  cursor: help;
}

.token.title,
.token.title .token.punctuation {
  font-weight: bold;
  color: #1d3e81;
}

.token.list {
  color: #ed6a43;
}

.token.inserted {
  background-color: #eaffea;
  color: #55a532;
}

.token.deleted {
  background-color: #ffecec;
  color: #bd2c00;
}

.token.bold {
  font-weight: bold;
}

.token.italic {
  font-style: italic;
}


/* JSON */
.language-json .token.property {
  color: #183691;
}

.language-markup .token.tag .token.punctuation {
  color: #333;
}

/* CSS */
code.language-css,
.language-css .token.function {
  color: #0086b3;
}

/* YAML */
.language-yaml .token.atrule {
  color: #63a35c;
}

code.language-yaml {
  color: #183691;
}

/* Ruby */
.language-ruby .token.function {
  color: #333;
}

/* Markdown */
.language-markdown .token.url {
  color: #795da3;
}

/* Makefile */
.language-makefile .token.symbol {
  color: #795da3;
}

.language-makefile .token.variable {
  color: #183691;
}

.language-makefile .token.builtin {
  color: #0086b3;
}

/* Bash */
.language-bash .token.keyword {
  color: #0086b3;
}

/* highlight */
pre[data-line] {
  position: relative;
  padding: 1em 0 1em 3em;
}
pre[data-line] .line-highlight-wrapper {
  position: absolute;
  top: 0;
  left: 0;
  background-color: transparent;
  display: block;
  width: 100%;
}

pre[data-line] .line-highlight {
  position: absolute;
  left: 0;
  right: 0;
  padding: inherit 0;
  margin-top: 1em;
  background: hsla(24, 20%, 50%,.08);
  background: linear-gradient(to right, hsla(24, 20%, 50%,.1) 70%, hsla(24, 20%, 50%,0));
  pointer-events: none;
  line-height: inherit;
  white-space: pre;
}

pre[data-line] .line-highlight:before, 
pre[data-line] .line-highlight[data-end]:after {
  content: attr(data-start);
  position: absolute;
  top: .4em;
  left: .6em;
  min-width: 1em;
  padding: 0 .5em;
  background-color: hsla(24, 20%, 50%,.4);
  color: hsl(24, 20%, 95%);
  font: bold 65%/1.5 sans-serif;
  text-align: center;
  vertical-align: .3em;
  border-radius: 999px;
  text-shadow: none;
  box-shadow: 0 1px white;
}

pre[data-line] .line-highlight[data-end]:after {
  content: attr(data-end);
  top: auto;
  bottom: .4em;
}html body{font-family:"Helvetica Neue",Helvetica,"Segoe UI",Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ul,html body>ol{margin-bottom:16px}html body ul,html body ol{padding-left:2em}html body ul.no-list,html body ol.no-list{padding:0;list-style-type:none}html body ul ul,html body ul ol,html body ol ol,html body ol ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:bold;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:bold}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em !important;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::before,html body code::after{letter-spacing:-0.2em;content:"\00a0"}html body pre>code{padding:0;margin:0;font-size:.85em !important;word-break:normal;white-space:pre;background:transparent;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;font-size:.85em !important;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:before,html body pre tt:before,html body pre code:after,html body pre tt:after{content:normal}html body p,html body blockquote,html body ul,html body ol,html body dl,html body pre{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body pre,html body code{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview .pagebreak,.markdown-preview .newpage{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center !important}.markdown-preview:not([for="preview"]) .code-chunk .btn-group{display:none}.markdown-preview:not([for="preview"]) .code-chunk .status{display:none}.markdown-preview:not([for="preview"]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0}@media screen and (min-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{font-size:14px !important;padding:1em}}@media print{html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,0.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p,html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div{display:inline}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% -  300px);padding:2em calc(50% - 457px -  300px/2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
    </head>
    <body for="html-export">
      <div class="mume markdown-preview  ">
      <div class="md-toc">
<details style="padding:0;;padding-left:0px;" open>
        <summary class="md-toc-link-wrapper">
          <a href="#-&#x6807;&#x51C6;&#x5E93;" class="md-toc-link"><p>&#x6807;&#x51C6;&#x5E93;</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#-&#x8865;&#x5145;clearerr-error-indicator" class="md-toc-link">
            <p>&#x8865;&#x5145;&#xFF1A;clearerr error indicator</p>

          </a></div><details style="padding:0;;padding-left:24px;" open>
        <summary class="md-toc-link-wrapper">
          <a href="#-stdio" class="md-toc-link"><p>stdio</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#-&#x6587;&#x4EF6;&#x64CD;&#x4F5C;" class="md-toc-link">
            <p>&#x6587;&#x4EF6;&#x64CD;&#x4F5C;</p>

          </a></div>
        </div>
      </details>
    <details style="padding:0;;padding-left:24px;" open>
        <summary class="md-toc-link-wrapper">
          <a href="#-math" class="md-toc-link"><p>math</p>
</a>
          </summary>
        <div>
          <div class="md-toc-link-wrapper" style="padding:0;;display:list-item;list-style:square;margin-left:42px">
          <a href="#-nan" class="md-toc-link">
            <p>NaN</p>

          </a></div>
        </div>
      </details>
    
        </div>
      </details>
    
</div>
<h1 class="mume-header" id="-%E6%A0%87%E5%87%86%E5%BA%93">&#x6807;&#x51C6;&#x5E93;</h1>

<table>
<thead>
<tr>
<th>&#x5934;</th>
<th>&#x51FD;&#x6570;</th>
<th>&#x5B9A;&#x4E49;</th>
</tr>
</thead>
<tbody>
<tr>
<td>stdio file operation</td>
<td>fopen</td>
<td><code>FILE *fopen(const char *filename, const char *mode)</code></td>
</tr>
<tr>
<td></td>
<td>freopen</td>
<td><code>FILE *freopen(const char *filename, const char *mode, FILE *stream)</code></td>
</tr>
<tr>
<td></td>
<td>fflush</td>
<td><code>int fflush(FILE *stream)</code></td>
</tr>
<tr>
<td></td>
<td>fclose</td>
<td><code>int fclose(FILE *stream)</code></td>
</tr>
<tr>
<td></td>
<td>remove</td>
<td><code>int remove(const char *filename)</code></td>
</tr>
<tr>
<td></td>
<td>rename</td>
<td><code>int rename(const char *oldname, const char *newname)</code></td>
</tr>
<tr>
<td></td>
<td>tmpfile</td>
<td><code>FILE *tmpfile(void)</code></td>
</tr>
<tr>
<td></td>
<td>tmpnam</td>
<td><code>char *tmpnam(char s[L_tmpnam])</code></td>
</tr>
<tr>
<td></td>
<td>setvbuf</td>
<td><code>int setvbuf(FILE *stream, char *buf, int mode, size_t size)</code></td>
</tr>
<tr>
<td></td>
<td>setbuf</td>
<td><code>void setbuf(FILE *stream, char *buf)</code></td>
</tr>
<tr>
<td>stdio formatted output</td>
<td>printf</td>
<td><code>int fprintf(FILE *stream, const char *format, ...)</code></td>
</tr>
<tr>
<td></td>
<td>fprintf</td>
<td><code>int fprintf(FILE *stream, const char *format, ...);</code></td>
</tr>
<tr>
<td></td>
<td>sprintf</td>
<td><code>int sprintf(char *str, const char *format, ...);</code></td>
</tr>
<tr>
<td></td>
<td>snprintf</td>
<td><code>int snprintf(char *str, size_t size, const char *format, ...);</code></td>
</tr>
<tr>
<td></td>
<td>vprintf</td>
<td><code>int vprintf(const char *format, va_list ap);</code></td>
</tr>
<tr>
<td></td>
<td>vfprintf</td>
<td><code>int vfprintf(FILE *stream, const char *format, va_list ap);</code></td>
</tr>
<tr>
<td></td>
<td>vsprintf</td>
<td><code>int vsprintf(char *str, const char *format, va_list ap);</code></td>
</tr>
<tr>
<td>stdio formatted input</td>
<td>scanf</td>
<td><code>int scanf(const char *format, ...);</code></td>
</tr>
<tr>
<td></td>
<td>fscanf</td>
<td><code>int fscanf(FILE *stream, const char *format, ...);</code></td>
</tr>
<tr>
<td></td>
<td>sscanf</td>
<td><code>int sscanf(const char *str, const char *format, ...);</code></td>
</tr>
<tr>
<td>char input/output</td>
<td>fgetc</td>
<td><code>int fgetc(FILE *stream);</code></td>
</tr>
<tr>
<td></td>
<td>fgets</td>
<td><code>char *fgets(char *s, int size, FILE *stream);</code></td>
</tr>
<tr>
<td></td>
<td>getc</td>
<td><code>int getc(FILE *stream);</code></td>
</tr>
<tr>
<td></td>
<td>getchar</td>
<td><code>int getchar(void);</code></td>
</tr>
<tr>
<td></td>
<td>gets</td>
<td><code>char *gets(char *s);</code></td>
</tr>
<tr>
<td></td>
<td>putc</td>
<td><code>int putc(int c, FILE *stream);</code></td>
</tr>
<tr>
<td></td>
<td>putchar</td>
<td><code>int putchar(int c);</code></td>
</tr>
<tr>
<td></td>
<td>puts</td>
<td><code>int puts(const char *s);</code></td>
</tr>
<tr>
<td></td>
<td>ungetc</td>
<td><code>int ungetc(int c, FILE *stream);</code></td>
</tr>
<tr>
<td>stdio direct input</td>
<td>fread</td>
<td><code>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);</code></td>
</tr>
<tr>
<td></td>
<td>fwrite</td>
<td><code>size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);</code></td>
</tr>
<tr>
<td>stdio &#x6587;&#x4EF6;&#x5B9A;&#x4F4D;</td>
<td>fseek</td>
<td><code>int fseek(FILE *stream, long offset, int whence);</code></td>
</tr>
<tr>
<td></td>
<td>ftell</td>
<td><code>long ftell(FILE *stream);</code></td>
</tr>
<tr>
<td></td>
<td>rewind</td>
<td><code>void rewind(FILE *stream);</code></td>
</tr>
<tr>
<td></td>
<td>fgetpos</td>
<td><code>int fgetpos(FILE *stream, fpos_t *pos);</code></td>
</tr>
<tr>
<td></td>
<td>fsetpos</td>
<td><code>int fsetpos(FILE *stream, const fpos_t *pos);</code></td>
</tr>
<tr>
<td>ctype.h</td>
<td>isdigit/isalpha/islower/isupper &#x7B49;&#x7B49;</td>
<td></td>
</tr>
<tr>
<td>string.h</td>
<td>strcpy</td>
<td><code>char *strcpy(char *dest, const char *src);</code></td>
</tr>
<tr>
<td></td>
<td>strncpy</td>
<td><code>char *strncpy(char *dest, const char *src, size_t n);</code></td>
</tr>
<tr>
<td></td>
<td>strcat</td>
<td><code>char *strcat(char *dest, const char *src);</code></td>
</tr>
<tr>
<td></td>
<td>strncat</td>
<td><code>char *strncat(char *dest, const char *src, size_t n);</code></td>
</tr>
<tr>
<td></td>
<td>strcmp</td>
<td><code>int strcmp(const char *s1, const char *s2);</code></td>
</tr>
<tr>
<td></td>
<td>strncmp</td>
<td><code>int strncmp(const char *s1, const char *s2, size_t n);</code></td>
</tr>
<tr>
<td></td>
<td>strchr</td>
<td><code>char *strchr(const char *s, int c);</code></td>
</tr>
<tr>
<td></td>
<td>strrchr</td>
<td><code>char *strrchr(const char *s, int c);</code></td>
</tr>
<tr>
<td></td>
<td>strspn</td>
<td><code>size_t strspn(const char *s, const char *accept);</code></td>
</tr>
<tr>
<td></td>
<td>strcspn</td>
<td><code>size_t strcspn(const char *s, const char *reject);</code></td>
</tr>
<tr>
<td></td>
<td>strpbrk</td>
<td><code>char *strpbrk(const char *s, const char *accept);</code></td>
</tr>
<tr>
<td></td>
<td>strstr</td>
<td><code>char *strstr(const char *haystack, const char *needle);</code></td>
</tr>
<tr>
<td></td>
<td>strlen</td>
<td><code>size_t strlen(const char *s);</code></td>
</tr>
<tr>
<td></td>
<td>strtok</td>
<td><code>char *strtok(char *s, const char *delim);</code></td>
</tr>
<tr>
<td>string.h &#x5185;&#x5B58;&#x64CD;&#x4F5C;</td>
<td>memcpy</td>
<td><code>void *memcpy(void *dest, const void *src, size_t n);</code></td>
</tr>
<tr>
<td></td>
<td>memset</td>
<td><code>void *memset(void *s, int c, size_t n);</code></td>
</tr>
<tr>
<td></td>
<td>memmove</td>
<td><code>void *memmove(void *dest, const void *src, size_t n);</code></td>
</tr>
<tr>
<td></td>
<td>memchr</td>
<td><code>void *memchr(const void *s, int c, size_t n);</code></td>
</tr>
<tr>
<td></td>
<td>memcmp</td>
<td><code>int memcmp(const void *s1, const void *s2, size_t n);</code></td>
</tr>
<tr>
<td>math</td>
<td>sin/cos/tan/.../exp/log/log10/sqrt/ceil/floor/.../fabs</td>
<td></td>
</tr>
<tr>
<td>stdlib</td>
<td>atof</td>
<td><code>double atof(const char *nptr);</code></td>
</tr>
<tr>
<td></td>
<td>atoi</td>
<td><code>int atoi(const char *nptr);</code></td>
</tr>
<tr>
<td></td>
<td>atol</td>
<td><code>long atol(const char *nptr);</code></td>
</tr>
<tr>
<td></td>
<td>strtod</td>
<td><code>double strtod(const char *nptr, char **endptr);</code></td>
</tr>
<tr>
<td></td>
<td>strtol</td>
<td><code>long int strtol(const char *nptr, char **endptr, int base);</code></td>
</tr>
<tr>
<td></td>
<td>strtoll</td>
<td><code>long long int strtoll(const char *nptr, char **endptr, int base);</code></td>
</tr>
<tr>
<td></td>
<td>rand</td>
<td><code>int rand(void);</code></td>
</tr>
<tr>
<td></td>
<td>srand</td>
<td><code>void srand(unsigned int seed);</code></td>
</tr>
<tr>
<td></td>
<td>malloc</td>
<td><code>void *malloc(size_t size);</code></td>
</tr>
<tr>
<td></td>
<td>free</td>
<td><code>void free(void *ptr);</code></td>
</tr>
<tr>
<td></td>
<td>calloc</td>
<td><code>void *calloc(size_t nmemb, size_t size);</code></td>
</tr>
<tr>
<td></td>
<td>realloc</td>
<td><code>void *realloc(void *ptr, size_t size);</code></td>
</tr>
<tr>
<td></td>
<td>exit</td>
<td><code>void exit(int status);</code></td>
</tr>
<tr>
<td></td>
<td>atexit</td>
<td><code>int atexit(void (*function)(void));</code></td>
</tr>
<tr>
<td></td>
<td>system</td>
<td><code>int system(const char *command);</code></td>
</tr>
<tr>
<td></td>
<td>getenv</td>
<td><code>char *getenv(const char *name);</code></td>
</tr>
<tr>
<td></td>
<td>qsort</td>
<td><code>void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));</code></td>
</tr>
<tr>
<td></td>
<td>div</td>
<td><code>div_t div(int numerator, int denominator);</code></td>
</tr>
<tr>
<td></td>
<td>ldiv</td>
<td><code>ldiv_t ldiv(long numerator, long denominator);</code></td>
</tr>
<tr>
<td>assert</td>
<td>assert</td>
<td><code>void assert(scalar expression);</code></td>
</tr>
<tr>
<td>stdarg</td>
<td>va_list va_start va_end</td>
<td></td>
</tr>
<tr>
<td>setjmp</td>
<td>setjmp</td>
<td><code>int setjmp(jmp_buf env);</code></td>
</tr>
<tr>
<td></td>
<td>longjmp</td>
<td>void longjmp(jmp_buf env, int val);</td>
</tr>
<tr>
<td>signal</td>
<td>sighandler_t</td>
<td><code>typedef void (*sighandler_t)(int);</code></td>
</tr>
<tr>
<td></td>
<td>signal</td>
<td><code>sighandler_t signal(int signum, sighandler_t handler);</code></td>
</tr>
<tr>
<td>time</td>
<td>clock</td>
<td><code>clock_t clock(void);</code></td>
</tr>
<tr>
<td></td>
<td>time</td>
<td><code>time_t time(time_t *tloc);</code></td>
</tr>
<tr>
<td></td>
<td>difftime</td>
<td><code>double difftime(time_t time1, time_t time0);</code></td>
</tr>
<tr>
<td></td>
<td>asctime</td>
<td><code>char *asctime(const struct tm *tm);</code></td>
</tr>
<tr>
<td></td>
<td>ctime</td>
<td><code>char *ctime(const time_t *timep);</code></td>
</tr>
<tr>
<td></td>
<td>gmtime</td>
<td><code>struct tm *gmtime(const time_t *timep);</code></td>
</tr>
<tr>
<td></td>
<td>localtime</td>
<td><code>struct tm *localtime(const time_t *timep);</code></td>
</tr>
<tr>
<td></td>
<td>mktime</td>
<td><code>time_t mktime(struct tm *tm);</code></td>
</tr>
<tr>
<td></td>
<td>strftime</td>
<td><code>size_t strftime(char *s, size_t max, const char *format, const struct tm *tm);</code></td>
</tr>
<tr>
<td></td>
<td>strptime</td>
<td><code>char *strptime(const char *s, const char *format, struct tm *tm);</code></td>
</tr>
</tbody>
</table>
<h2 class="mume-header" id="-%E8%A1%A5%E5%85%85clearerr-error-indicator">&#x8865;&#x5145;&#xFF1A;clearerr error indicator</h2>

<p>The clearerr() function clears the end-of file and error indicators for the given stream. In C programming, clearerr() clears the end-of-file and error indicators for the given stream.</p>
<p>The clearerr function resets the error indicator and end-of-file indicator for stream. Error indicators are not automatically cleared; once the error indicator for a specified stream is set, operations on that stream continue to return an error value until clearerr, fseek, fsetpos, or rewind is called.</p>
<p>Each stream has &quot;an error indicator that records whether a read/write error has occurred&quot;.</p>
<p>It is set, usually rarely, by various functions: fgetc(), fflush(), fseek(), ....</p>
<p>It is cleared by various functions: rewind(), clearerr(), fopen(), ....</p>
<p>int ferror(FILE *stream) reports the state.</p>
<h2 class="mume-header" id="-stdio">stdio</h2>

<h3 class="mume-header" id="-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C">&#x6587;&#x4EF6;&#x64CD;&#x4F5C;</h3>

<p><code>FILE *fopen(const char *filename, const char *mode)</code><br>
fopen &#x51FD;&#x6570;&#x6253;&#x5F00; filename &#x6307;&#x5B9A;&#x7684;&#x6587;&#x4EF6;&#xFF0C;&#x5E76;&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;&#x4E0E;&#x4E4B;&#x76F8;&#x5173;&#x8054;&#x7684;&#x6D41;&#x3002;&#x5982;&#x679C;&#x6253;&#x5F00;&#x64CD;&#x4F5C;&#x5931;&#x8D25;&#xFF0C;&#x5219;&#x8FD4;&#x56DE; NULL&#x3002;<br>
&#x8BBF;&#x95EE;&#x6A21;&#x5F0F; mode &#x53EF;&#x4EE5;&#x4E3A;&#x4E0B;&#x5217;&#x5408;&#x6CD5;&#x503C;&#x4E4B;&#x4E00;:<br>
&quot;r&quot; &#x6253;&#x5F00;&#x6587;&#x672C;&#x6587;&#x4EF6;&#x7528;&#x4E8E;&#x8BFB;<br>
&quot;w&quot; &#x521B;&#x5EFA;&#x6587;&#x672C;&#x6587;&#x4EF6;&#x7528;&#x4E8E;&#x5199;&#xFF0C;&#x5E76;&#x5220;&#x9664;&#x5DF2;&#x5B58;&#x5728;&#x7684;&#x5185;&#x5BB9;(&#x5982;&#x679C;&#x6709;&#x7684;&#x8BDD;)<br>
&quot;a&quot; &#x8FFD;&#x52A0;;&#x6253;&#x5F00;&#x6216;&#x521B;&#x5EFA;&#x6587;&#x672C;&#x6587;&#x4EF6;&#xFF0C;&#x5E76;&#x5411;&#x6587;&#x4EF6;&#x672B;&#x5C3E;&#x8FFD;&#x52A0;&#x5185;&#x5BB9;<br>
&quot;r+&quot; &#x6253;&#x5F00;&#x6587;&#x672C;&#x6587;&#x4EF6;&#x7528;&#x4E8E;&#x66F4;&#x65B0;(&#x5373;&#x8BFB;&#x548C;&#x5199;)<br>
&quot;w+&quot; &#x521B;&#x5EFA;&#x6587;&#x672C;&#x6587;&#x4EF6;&#x7528;&#x4E8E;&#x66F4;&#x65B0;&#xFF0C;&#x5E76;&#x5220;&#x9664;&#x5DF2;&#x5B58;&#x5728;&#x7684;&#x5185;&#x5BB9;(&#x5982;&#x679C;&#x6709;&#x7684;&#x8BDD;)<br>
&quot;a+&quot; &#x8FFD;&#x52A0;;&#x6253;&#x5F00;&#x6216;&#x521B;&#x5EFA;&#x6587;&#x672C;&#x6587;&#x4EF6;&#x7528;&#x4E8E;&#x66F4;&#x65B0;&#xFF0C;&#x5199;&#x6587;&#x4EF6;&#x65F6;&#x8FFD;&#x52A0;&#x5230;&#x6587;&#x4EF6;&#x672B;&#x5C3E;<br>
&#x540E; 3 &#x79CD;&#x65B9;&#x5F0F;(&#x66F4;&#x65B0;&#x65B9;&#x5F0F;)&#x5141;&#x8BB8;&#x5BF9;&#x540C;&#x4E00;&#x6587;&#x4EF6;&#x8FDB;&#x884C;&#x8BFB;&#x548C;&#x5199;&#x3002;&#x5728;&#x8BFB;&#x548C;&#x5199;&#x7684;&#x4EA4;&#x53C9;&#x8FC7;&#x7A0B;&#x4E2D;&#xFF0C;&#x5FC5;&#x987B;&#x8C03; &#x7528; fflush &#x51FD;&#x6570;&#x6216;&#x6587;&#x4EF6;&#x5B9A;&#x4F4D;&#x51FD;&#x6570;&#x3002;</p>
<p>&#x6587;&#x4EF6;&#x540D; filename &#x9650;&#x5B9A;&#x6700;&#x591A;&#x4E3A; FILENAME_MAX &#x4E2A;&#x5B57;&#x7B26;&#x3002;&#x4E00; &#x6B21;&#x6700;&#x591A;&#x53EF;&#x6253;&#x5F00; FOPEN_MAX &#x4E2A;&#x6587;&#x4EF6;&#x3002;</p>
<p>&#x8865;&#x5145;</p>
<p>The argument mode points to a string beginning with one of the following<br>
sequences (Additional characters may follow these sequences.):</p>
<p>``r&apos;&apos;   Open text file for reading.  The stream is positioned at the<br>
beginning of the file.</p>
<p>``r+&apos;&apos;  Open for reading and writing.  The stream is positioned at the<br>
beginning of the file.</p>
<p>``w&apos;&apos;   Truncate file to zero length or create text file for writing.<br>
The stream is positioned at the beginning of the file.</p>
<p>``w+&apos;&apos;  Open for reading and writing.  The file is created if it does not<br>
exist, otherwise it is truncated.  The stream is positioned at<br>
the beginning of the file.</p>
<p>``a&apos;&apos;   Open for writing.  The file is created if it does not exist.  The<br>
stream is positioned at the end of the file.  Subsequent writes<br>
to the file will always end up at the then current end of file,<br>
irrespective of any intervening fseek(3) or similar.</p>
<p>``a+&apos;&apos;  Open for reading and writing.  The file is created if it does not<br>
exist.  The stream is positioned at the end of the file.  Subse-<br>
quent writes to the file will always end up at the then current<br>
end of file, irrespective of any intervening fseek(3) or similar.</p>
<p><code>FILE *freopen(const char *filename, const char *mode, FILE *stream)</code></p>
<p>freopen &#x51FD;&#x6570;&#x4EE5; mode &#x6307;&#x5B9A;&#x7684;&#x6A21;&#x5F0F;&#x6253;&#x5F00; filename &#x6307;&#x5B9A;&#x7684;&#x6587;&#x4EF6;&#xFF0C;&#x5E76;&#x5C06;&#x8BE5;&#x6587;&#x4EF6;&#x5173;&#x8054;&#x5230; stream &#x6307;&#x5B9A;&#x7684;&#x6D41;&#x3002;&#x5B83;&#x8FD4;&#x56DE; stream;&#x82E5;&#x51FA;&#x9519;&#x5219;&#x8FD4;&#x56DE; NULL&#x3002;Freopen &#x51FD;&#x6570;&#x4E00;&#x822C;&#x7528;&#x4E8E;&#x6539;&#x53D8;&#x4E0E; stdin&#x3001;stdout &#x548C; stderr &#x76F8;&#x5173;&#x8054;&#x7684;&#x6587;&#x4EF6;&#x3002;</p>
<p><code>int fflush(FILE *stream)</code></p>
<p>&#x5BF9;&#x8F93;&#x51FA;&#x6D41;&#x6765;&#x8BF4;&#xFF0C;fflush &#x51FD;&#x6570;&#x5C06;&#x5DF2;&#x5199;&#x5230;&#x7F13;&#x51B2;&#x533A;&#x4F46;&#x5C1A;&#x672A;&#x5199;&#x5165;&#x6587;&#x4EF6;&#x7684;&#x6240;&#x6709;&#x6570;&#x636E;&#x5199;&#x5230;&#x6587;&#x4EF6;&#x4E2D;&#x3002;&#x5BF9; &#x8F93;&#x5165;&#x6D41;&#x6765;&#x8BF4;&#xFF0C;&#x5176;&#x7ED3;&#x679C;&#x662F;&#x672A;&#x5B9A;&#x4E49;&#x7684;&#x3002;&#x5982;&#x679C;&#x5728;&#x5199;&#x7684;&#x8FC7;&#x7A0B;&#x4E2D;&#x53D1;&#x751F;&#x9519;&#x8BEF;&#xFF0C;&#x5219;&#x8FD4;&#x56DE; EOF&#xFF0C;&#x5426;&#x5219;&#x8FD4;&#x56DE; 0&#x3002;fflush(NULL)&#x5C06;&#x6E05;&#x6D17;&#x6240;&#x6709;&#x7684;&#x8F93;&#x51FA;&#x6D41;&#x3002;</p>
<p><code>int fclose(FILE *stream)</code><br>
fclose &#x51FD;&#x6570;&#x5C06;&#x6240;&#x6709;&#x672A;&#x5199;&#x5165;&#x7684;&#x6570;&#x636E;&#x5199;&#x5165; stream &#x4E2D;&#xFF0C;&#x4E22;&#x5F03;&#x7F13;&#x51B2;&#x533A;&#x4E2D;&#x7684;&#x6240;&#x6709;&#x672A;&#x8BFB;&#x8F93;&#x5165;&#x6570;&#x636E;&#xFF0C;&#x5E76;&#x91CA;&#x653E;&#x81EA;&#x52A8;&#x5206;&#x914D;&#x7684;&#x5168;&#x90E8;&#x7F13;&#x51B2;&#x533A;&#xFF0C;&#x6700;&#x540E;&#x5173;&#x95ED;&#x6D41;&#x3002;&#x82E5;&#x51FA;&#x9519;&#x5219;&#x8FD4;&#x56DE; EOF&#xFF0C;&#x5426;&#x5219;&#x8FD4;&#x56DE; 0&#x3002;</p>
<p>&#x8865;&#x5145;&#xFF1A;Flushes a stream, and then closes the file associated with that stream. Afterwards, the function releases any buffers associated with the stream. To flush means that unwritten buffered data is written to the file, and unread buffered data is discarded. &#x5E94;&#x8BE5;&#x5C31;&#x662F;&#x7F13;&#x5B58;&#x533A;&#x7684;&#x6570;&#x636E;&#x5199;&#x5165;&#x6587;&#x4EF6;&#xFF0C;&#x6CA1;&#x6709;&#x8BFB;&#x7684; buffer &#x6570;&#x636E;&#x5C31;&#x4E22;&#x5F03;&#x4E0D;&#x8BFB;&#x4E86;&#x3002;</p>
<p><code>int remove(const char *filename)</code><br>
remove &#x51FD;&#x6570;&#x5220;&#x9664; filename &#x6307;&#x5B9A;&#x7684;&#x6587;&#x4EF6;&#xFF0C;&#x8FD9;&#x6837;&#xFF0C;&#x540E;&#x7EED;&#x8BD5;&#x56FE;&#x6253;&#x5F00;&#x8BE5;&#x6587;&#x4EF6;&#x7684;&#x64CD;&#x4F5C;&#x5C06;&#x5931;&#x8D25;&#x3002; &#x5982;&#x679C;&#x5220;&#x9664;&#x64CD;&#x4F5C;&#x5931;&#x8D25;&#xFF0C;&#x5219;&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;&#x975E; 0 &#x503C;&#x3002;</p>
<p><code>int rename(const char *oldname, const char *newname)</code> rename &#x51FD;&#x6570;&#x4FEE;&#x6539;&#x6587;&#x4EF6;&#x7684;&#x540D;&#x5B57;&#x3002;&#x5982;&#x679C;&#x64CD;&#x4F5C;&#x5931;&#x8D25;&#xFF0C;&#x5219;&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;&#x975E; 0 &#x503C;&#x3002;</p>
<p><code>FILE *tmpfile(void)</code></p>
<p>tmpfile &#x51FD;&#x6570;&#x4EE5;&#x6A21;&#x5F0F;&quot;wb+&quot;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x4E34;&#x65F6;&#x6587;&#x4EF6;&#xFF0C;&#x8BE5;&#x6587;&#x4EF6;&#x5728;&#x88AB;&#x5173;&#x95ED;&#x6216;&#x7A0B;&#x5E8F;&#x6B63;&#x5E38;&#x7ED3;&#x675F;&#x65F6;&#x5C06;&#x88AB;&#x81EA;&#x52A8;&#x5220;&#x9664;&#x3002;&#x5982;&#x679C;&#x521B;&#x5EFA;&#x64CD;&#x4F5C;&#x6210;&#x529F;&#xFF0C;&#x8BE5;&#x51FD;&#x6570;&#x8FD4;&#x56DE;&#x4E00;&#x4E2A;&#x6D41;; &#x5982;&#x679C;&#x521B;&#x5EFA;&#x6587;&#x4EF6;&#x5931;&#x8D25;&#xFF0C;&#x5219;&#x8FD4;&#x56DE; NULL&#x3002;</p>
<p>fopen vs freopen:</p>
<ul>
<li>&#x591A;&#x4E00;&#x4E2A; stream &#x53C2;&#x6570;&#x3002;</li>
<li>According to POSIX (see application usage section), freopen was originally added to C to facilitate changing stdin and stdout to binary mode. I</li>
</ul>
<h2 class="mume-header" id="-math">math</h2>

<p>gcc &#x7F16;&#x8BD1;&#x9700;&#x8981;&#x589E;&#x52A0;-lm</p>
<p>The math library must be linked in when building the executable. How to do this varies by environment, but in Linux/Unix, just add -lm to the command:</p>
<p><code>gcc test.c -o test -lm</code><br>
The math library is named <a href="http://libm.so">libm.so</a>, and the -l command option assumes a lib prefix and .a or .so suffix.</p>
<h3 class="mume-header" id="-nan">NaN</h3>

<p>not a number</p>
<p>&#x4F1A;&#x8FD4;&#x56DE; NaN &#x7684;&#x8FD0;&#x7B97;&#x6709;&#x5982;&#x4E0B;&#x4E09;&#x79CD;&#xFF1A;</p>
<ol>
<li>&#x64CD;&#x4F5C;&#x6570;&#x4E2D;&#x81F3;&#x5C11;&#x6709;&#x4E00;&#x4E2A;&#x662F; NaN &#x7684;&#x8FD0;&#x7B97;</li>
<li>&#x672A;&#x5B9A;&#x4E49;&#x64CD;&#x4F5C;<br>
&#x4E0B;&#x5217;&#x9664;&#x6CD5;&#x8FD0;&#x7B97;&#xFF1A;0/0&#x3001;&#x221E;/&#x221E;&#x3001;&#x221E;/&#x2212;&#x221E;&#x3001;&#x2212;&#x221E;/&#x221E;&#x3001;&#x2212;&#x221E;/&#x2212;&#x221E;<br>
&#x4E0B;&#x5217;&#x4E58;&#x6CD5;&#x8FD0;&#x7B97;&#xFF1A;0&#xD7;&#x221E;&#x3001;0&#xD7;-&#x221E;<br>
&#x4E0B;&#x5217;&#x52A0;&#x6CD5;&#x8FD0;&#x7B97;&#xFF1A;&#x221E; + (&#x2212;&#x221E;)&#x3001;(&#x2212;&#x221E;) + &#x221E;<br>
&#x4E0B;&#x5217;&#x51CF;&#x6CD5;&#x8FD0;&#x7B97;&#xFF1A;&#x221E; - (&#x2212;&#x221E;)&#x3001;(&#x2212;&#x221E;) - &#x221E;</li>
<li>&#x4EA7;&#x751F;&#x590D;&#x6570;&#x7ED3;&#x679C;&#x7684;&#x5B9E;&#x6570;&#x8FD0;&#x7B97;&#x3002;&#x4F8B;&#x5982;&#xFF1A;<br>
&#x5BF9;&#x8D1F;&#x6570;&#x8FDB;&#x884C;&#x5F00;&#x65B9;&#x8FD0;&#x7B97;<br>
&#x5BF9;&#x8D1F;&#x6570;&#x8FDB;&#x884C;&#x5BF9;&#x6570;&#x8FD0;&#x7B97;<br>
&#x5BF9;&#x6BD4;-1 &#x5C0F;&#x6216;&#x6BD4;+1 &#x5927;&#x7684;&#x6570;&#x8FDB;&#x884C;&#x53CD;&#x6B63;&#x5F26;&#x6216;&#x53CD;&#x4F59;&#x5F26;&#x8FD0;&#x7B97;</li>
</ol>
<pre data-role="codeBlock" data-info="C" class="language-c"><span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// Floating point exception (core dumped)</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%lf %lf\n&quot;</span><span class="token punctuation">,</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// -nan, -inf</span>
</pre><p><a href="https://www.gnu.org/software/libc/manual/html_node/Infinity-and-NaN.html">https://www.gnu.org/software/libc/manual/html_node/Infinity-and-NaN.html</a></p>

      </div>
      
      
    
    
    
    
    
    
    
    
  
    </body></html>